‚úÖ MASTER GENERATION PROMPT ‚Äî Components & Materials (REVISED)

You are generating a Web Component following a strict architecture.

Before generating code, identify whether you are generating:

‚¨ú Component
‚¨ú Material

Then follow all rules below.

üè∑Ô∏è NAMING CONVENTIONS ‚Äî CHECKLIST (MANDATORY)
File & Folder Naming

‚¨ú All folders and file base names use kebab-case
‚¨ú Each component/material has exactly:

<name>.html

<name>.css

<name>.js

Examples:

comment-box/comment-box.html
text-area-material/text-area-material.js

Custom Element Tag Naming (NAMESPACED)

‚¨ú All custom elements MUST be namespaced with ui-

Formats:

‚¨ú Component tag: ui-<kebab-name>
‚¨ú Material tag: ui-<kebab-name>-m

Examples:

Component: ui-comment-box

Material: ui-text-area-m

JavaScript Class Naming

‚¨ú Class names use PascalCase
‚¨ú All classes are prefixed with Ui

Formats:

‚¨ú Component class: Ui<PascalName>
‚¨ú Material class: Ui<PascalName>Material

Examples:

ui-comment-box ‚Üí UiCommentBox
ui-text-area-m ‚Üí UiTextAreaMaterial

Tag Consistency Rule (CRITICAL)

‚¨ú The exact same tag string must be used in:

customElements.define(...)

asset loaders

HTML usage

One tag string per component/material.

CSS Naming (UPDATED ‚Äî CONSISTENT WITH REAL CODE)

‚¨ú Every CSS class or ID must start with the component/material name
‚¨ú ui- prefix IS allowed in CSS
‚¨ú No generic selectors (h1, p, button, etc.)

Example:

.ui-column-retro-root {}
.ui-board-gallery-shell {}

üîß GENERAL STRUCTURE RULES
Files

Generate three files:

üìÑ <name>.html
üé® <name>.css
üß© <name>.js

HTML

‚¨ú Only markup
‚¨ú No <style> or <script>

CSS

‚¨ú No generic selectors
‚¨ú All selectors prefixed by component/material name

üß† ARCHITECTURAL BOUNDARY

System layers:

Material ‚Üí Component ‚Üí Behavior

‚úÖ MATERIAL CHECKLIST

A Material is a generic, self-contained UI primitive.

‚¨ú Wraps a single UI element
‚¨ú Defines HTML + CSS
‚¨ú May manage internal UI state
‚¨ú May emit generic events
‚¨ú May expose callbacks

‚¨ú Must NOT coordinate other components/materials
‚¨ú Must NOT call loadComponentAssets
‚¨ú Must NOT orchestrate domain logic

‚¨ú Calls ONLY loadMaterialsAssets

‚ö†Ô∏è Render Rule (UPDATED)

‚¨ú Render may attach listeners ONLY to newly created elements
‚¨ú Render must not accumulate listeners across renders

‚úÖ COMPONENT CHECKLIST

A Component is the owner and orchestrator.

‚¨ú Owns domain behavior
‚¨ú Coordinates materials
‚¨ú Owns state and workflows
‚¨ú Calls loadComponentAssets

üîÑ LIFECYCLE STRUCTURE (MANDATORY)

Each component/material must implement:

1) initializeOnce()

‚¨ú Asset loading
‚¨ú DOM queries
‚¨ú Event listeners
‚¨ú Internal setup

Guard:

if (this._initialized) return;
this._initialized = true;

2) onConnected()

‚¨ú Sync state ‚Üí UI
‚¨ú Refresh visuals

Required connectedCallback pattern:
async connectedCallback() {
  if (!this._initialized) {
    await this.initializeOnce();
    this._initialized = true;
  }
  this.onConnected();
}


Law: connectedCallback must be idempotent.


EVENT OWNERSHIP & SHADOW DOM RULE ‚Äî CHECKLIST (MANDATORY)
EVENT EMISSION RULE (CHILD ‚Üí OWNER)

‚¨ú Components must communicate intentions exclusively through custom events
‚¨ú Events must propagate beyond Shadow DOM boundaries
‚¨ú Components must not directly manipulate parent structures
‚¨ú Components must not remove or reorder themselves when wrapped by an owner shell
‚¨ú Components must express intent, not execution

Law:

A component expresses intent; the owner executes changes.

EVENT LISTENING RULE (OWNER)

‚¨ú Owner components must listen to child events at the component boundary
‚¨ú Owner components must not rely on internal DOM nodes for event listening
‚¨ú Owner components must not attach listeners to dynamic containers for cross-component communication
‚¨ú Internal DOM must be treated as unstable and non-authoritative

Law:

The owner listens at the highest stable boundary.

SHADOW DOM COMMUNICATION LAW

‚¨ú Communication across components must not depend on internal DOM structure
‚¨ú Shadow DOM boundaries must be assumed to interrupt container-based event delegation
‚¨ú Component-level event listening is mandatory for cross-component coordination

Law:

Component boundaries define communication boundaries.

üß© COMPONENT OWNERSHIP RULE
‚ùó Component cannot delete itself

If wrapped by a parent shell, the component must emit intent, not mutate DOM.

Example:

Component emits: ui-column-delete

Parent removes the shell.

üß± SHELL WRAPPER PATTERN (NEW ‚Äî FORMALIZED)

When a parent needs to move/reorder child components:

‚¨ú Parent must wrap the component in a shell element
‚¨ú Shell is owned by the parent
‚¨ú Shell is the draggable/reorderable unit

Example:

<div class="shell">
  <ui-column-retro></ui-column-retro>
</div>


Law:

A component is never draggable ‚Äî only its parent shell is.

üß≤ DRAGGING & OWNERSHIP RULE (REVISED)
CORE LAW

‚¨ú A component must never move itself
‚¨ú A component must never reorder itself among siblings
‚¨ú Only parents may reorder child components

‚¨ú A component must never set draggable="true" on its host element
‚¨ú Drag logic must never target the custom element tag itself

‚úÖ ALLOWED DRAGGING TYPES
üÖ∞Ô∏è HANDLE DRAG (MANDATORY for components)

Used for moving/reordering components (columns, widgets, etc.)

‚¨ú Drag starts ONLY from a dedicated handle element
‚¨ú Handle belongs to the parent shell
‚¨ú If drag does not start from handle ‚Üí cancel

Example handles:

move icon

grip

header bar

üÖ±Ô∏è FULL-ITEM DRAG (ALLOWED for internal items)

Used for internal list items (cards, rows, list items).

‚¨ú Drag may start from any part of the internal item
‚¨ú Item must NOT be the component host
‚¨ú Item must be an internal shell element

Example:

<div class="card-shell" draggable="true">
  <ui-card-retro></ui-card-retro>
</div>

‚ùó IMPORTANT DISTINCTION

Forbidden:

dragging a component tag (ui-column-retro)

component handling drag to move itself

Allowed:

dragging internal shells

parent orchestrating movement

üß† DRAG CONTEXT ISOLATION RULE

‚¨ú Only one drag system may be active per gesture
‚¨ú Components must ignore drag events outside their domain
‚¨ú Parent drag must not break child drag
‚¨ú Child drag must not interfere with parent drag

üß† COMPONENT DRAG RESPONSIBILITY SPLIT
Child Component Responsibilities

‚¨ú Expose drop zone API (e.g. getDropZone())
‚¨ú Create internal draggable shells
‚¨ú Never orchestrate cross-component drag

Parent Component Responsibilities

‚¨ú Detect drag context (column vs card)
‚¨ú Compute drop targets
‚¨ú Insert placeholders
‚¨ú Move shells across components

Law:

Cross-component drag belongs to the parent.

üñ•Ô∏è LAYOUT & SCROLLING RULE (REVISED)
ROOT LAYOUT RULES

‚¨ú Root must fill viewport naturally
‚¨ú Use min-height: 100dvh (or 100vh fallback)
‚¨ú Do NOT set height: 100vh
‚¨ú Do NOT set overflow-y on root

Result:

Page scroll happens only when content exceeds viewport.

SCROLL RESPONSIBILITY

‚¨ú Vertical scroll ‚Üí document level
‚¨ú Horizontal scroll ‚Üí allowed only for structural containers (boards, timelines)

FORBIDDEN PATTERNS

‚¨ú height: 100vh + overflow:auto
‚¨ú scroll trapped inside component
‚¨ú nested vertical scroll without justification

üß† MATERIAL PUBLIC API RULE

Every material must implement:

‚¨ú getNativeElement()
‚¨ú focus() (if applicable)
‚¨ú value getter/setter (if input-like)
‚¨ú disabled forwarding

Forbidden:

‚¨ú accessing material.shadowRoot externally
‚¨ú domain logic inside materials

üß™ SELF-VERIFICATION CHECKLIST

Before output, verify:

‚¨ú naming rules
‚¨ú lifecycle separation
‚¨ú no duplicate listeners
‚¨ú correct asset loader
‚¨ú no component is draggable
‚¨ú drag only on shells/handles
‚¨ú parent owns reordering
‚¨ú scroll rules respected

If any rule fails ‚Üí regenerate.

üì§ OUTPUT FORMAT

Return exactly:

üìÑ <name>.html
üé® <name>.css
üß© <name>.js