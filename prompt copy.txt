‚úÖ MASTER GENERATION PROMPT ‚Äî Components & Materials

You are generating a Web Component following a strict architecture.

Before generating code, you must identify whether you are generating:

‚¨ú Component
‚¨ú Material

Then follow all rules below.

üè∑Ô∏è NAMING CONVENTIONS ‚Äî CHECKLIST (MANDATORY)

All naming rules below are strict and non-negotiable.

File & Folder Naming

‚¨ú All folders and file base names use kebab-case
‚¨ú Each component/material has exactly:

<name>.html

<name>.css

<name>.js

Examples:

comment-box/comment-box.html

text-area-material/text-area-material.js

Custom Element Tag Naming (NAMESPACED)

‚¨ú All custom elements MUST be namespaced with ui-

Tag formats

‚¨ú Component tag: ui-<kebab-name>
‚¨ú Material tag: ui-<kebab-name>-m

Examples:

Component: ui-comment-box

Material: ui-text-area-m

JavaScript Class Naming

‚¨ú Class names use PascalCase
‚¨ú All classes are prefixed with Ui

Class formats

‚¨ú Component class: Ui<PascalName>
‚¨ú Material class: Ui<PascalName>Material

Examples:

ui-comment-box ‚Üí UiCommentBox

ui-text-area-m ‚Üí UiTextAreaMaterial

Tag Consistency Rule (VERY IMPORTANT)

‚¨ú The exact same tag string must be used in:

customElements.define("tag-name", ClassName)

asset loaders (loadComponentAssets / loadMaterialsAssets)

One tag string per component/material. No variations.

CSS Naming

‚¨ú Every CSS class or ID must start with the file base name
‚¨ú No ui- prefix in CSS class names
‚¨ú No generic selectors (h1, p, button, etc.)

Example:

.comment-box-root {}
.text-area-material-input {}

üîß GENERAL STRUCTURE RULES (ALWAYS APPLY)
Files

Generate three separate files, each in its own code block:

<name>.html

<name>.css

<name>.js

HTML

‚¨ú Contains only HTML
‚¨ú No <style> or <script> tags

CSS

‚¨ú Every class or ID starts with the component/material name
‚¨ú ‚ùå No generic selectors (h1, p, button, etc.)
‚¨ú ‚úîÔ∏è Always use classes or IDs

üß† ARCHITECTURAL BOUNDARY ‚Äî CHECKLIST (MANDATORY)

The system has three layers:

Material  ‚Üí  Component  ‚Üí  Behavior

‚úÖ MATERIAL CHECKLIST (UPDATED ‚Äî ALL MUST BE TRUE)

A Material is a SELF-CONTAINED, GENERIC UI element.
It may include simple, common UI behavior, but must not coordinate with other components or materials.

‚¨ú Wraps a single base UI element (button, input, textarea, etc.)
‚¨ú Defines HTML structure and CSS styles
‚¨ú May include simple, generic UI behavior that affects only itself
‚¨ú May manage internal UI state (e.g. isEditing, toggles, counters)
‚¨ú May expose generic callbacks (onSave, onChange, onCancel)
‚¨ú May emit generic UI events (input, change, save)

‚¨ú Must NOT load or coordinate other components or materials
‚¨ú Must NOT call loadComponentIfNotExists
‚¨ú Must NOT call loadMaterialsIfNotExists
‚¨ú Must NOT query or manipulate external components
‚¨ú Must NOT contain domain-specific rules or workflows

‚¨ú Calls ONLY loadMaterialsAssets
‚¨ú Does NOT call loadComponentAssets

‚¨ú A material must contain CSS, but that CSS must be purely presentational and must not encode business or domain rules.

Asset loading (material only):
await loadMaterialsAssets(this, "material-tag-name");


Law (UPDATED):

If the behavior requires knowledge of another component/material or a domain workflow, it does NOT belong to a material.

‚úÖ COMPONENT CHECKLIST (ALL MUST BE TRUE)



A Component is the OWNER and ORCHESTRATOR.

‚¨ú Owns behavior and intent
‚¨ú Coordinates one or more materials
‚¨ú Implements validation, limits, formatting, and UX rules
‚¨ú Decides when and how things happen
‚¨ú Attaches event listeners
‚¨ú Owns state and configuration
‚¨ú May emit domain-specific custom events
‚¨ú Calls loadComponentAssets

Asset loading (component only):
await loadComponentAssets(this, "component-tag-name");

üß† EVENT LISTENER RULE ‚Äî CHECKLIST (MANDATORY)

Event listeners must be attached exactly once.

‚¨ú Event listeners must be attached during the connected lifecycle, and only once.
‚¨ú Event listeners must be attached only once per element
‚¨ú Repeated executions of connectedCallback() must NOT register duplicate listeners
‚¨ú Components and materials must guard against multiple listener registrations

‚ùå Forbidden

‚¨ú Adding event listeners inside render functions without guards
‚¨ú Adding event listeners inside setters/getters
‚¨ú Adding the same listener multiple times for the same element
‚¨ú Assuming connectedCallback() runs only once

üîÑ LIFECYCLE STRUCTURE ‚Äî CHECKLIST (NEW, MANDATORY)

connectedCallback() may execute multiple times during the life of a component.

Therefore, lifecycle logic MUST be separated.

REQUIRED LIFECYCLE PATTERN

Each component and material must logically separate:

1Ô∏è‚É£ One-time initialization

Logic that must run only once per instance.

‚¨ú Asset loading
‚¨ú Querying static DOM references
‚¨ú Attaching event listeners
‚¨ú Creating observers or timers
‚¨ú Initial internal setup

This logic MUST live in:

initializeOnce()


and MUST be guarded:

if (this._initialized) return;
this._initialized = true;

2Ô∏è‚É£ Connection logic

Logic that may safely run every time the element is connected.

‚¨ú Syncing attributes ‚Üí DOM
‚¨ú Refreshing layout or visual state
‚¨ú Re-applying external configuration

This logic MUST live in:

onConnected()

REQUIRED connectedCallback STRUCTURE
async connectedCallback() {
  if (!this._initialized) {
    await this.initializeOnce();
    this._initialized = true;
  }

  this.onConnected();
}


‚ùå Forbidden

‚¨ú Putting all logic directly inside connectedCallback()
‚¨ú Blocking reconnection logic behind _initialized
‚¨ú Reloading assets or re-attaching listeners on every connection

Law:

connectedCallback() must be idempotent.


üß© BEHAVIOR RULE (STRICT)

Behavior includes:

character limits

auto-resize

formatting

validation

conditional flows

side effects

domain workflows

‚¨ú ALL domain behavior must live inside the COMPONENT
‚¨ú Materials may contain only self-contained, generic UI behavior

üß± SLOTS ‚Äî STRUCTURE & COMPOSITION (MANDATORY CHECKLIST)

Slots define structure only, never behavior.

‚¨ú Slots are defined ONLY in Materials
‚¨ú Slots define where content goes, not what it means
‚¨ú Slots contain NO logic
‚¨ú Slot presence or absence must not change behavior
‚¨ú Empty slots handled by CSS only (:empty { display: none })
‚¨ú Materials do NOT inspect slot content
‚¨ú Materials do NOT branch logic based on slot existence
‚¨ú Components decide what content is placed into slots

üîÅ ATTRIBUTE vs PROPERTY ‚Äî CHECKLIST (MANDATORY)

‚¨ú Attributes are declarative and string-based
‚¨ú Properties are dynamic or non-string runtime data
‚¨ú Attributes represent configuration, not behavior
‚¨ú Boolean attributes use presence (disabled)
‚¨ú Materials may forward attributes but must not interpret them as rules

üß© Rule ‚Äî Component cannot delete itself

A component must never remove itself from the DOM when it is wrapped by a shell owned by another component.

Instead, it must emit a semantic event describing the intention.

The owner component (shell owner) is responsible for removing the element.

Example pattern:

Component emits: ui-column-delete

Owner handles removal.


üß© MATERIAL PUBLIC API ‚Äî CHECKLIST (MANDATORY)

Every Material must implement a minimal public API.

Required for all materials

‚¨ú getNativeElement() returns the wrapped base UI element
‚¨ú focus() forwards focus (if applicable)
‚¨ú disabled is supported via attribute/property forwarding
‚¨ú Public methods contain no domain logic

Required for input-like materials

‚¨ú value getter/setter forwards to the native element‚Äôs value
‚¨ú No validation, formatting, or limits in the material‚Äôs value setter

Forbidden

‚¨ú No component should access material.shadowRoot.querySelector(...)
‚¨ú No coordination logic with other components/materials

üì¶ JAVASCRIPT STRUCTURE RULES
‚ùå FORBIDDEN

‚¨ú No BaseComponent
‚¨ú No extends BaseComponent

‚úÖ REQUIRED BASE CLASS

All components and materials must extend HTMLElement.

Constructor (MANDATORY)
constructor() {
  super();
  this.attachShadow({ mode: "open" });
}


‚¨ú No other logic inside the constructor

Lifecycle

‚¨ú Implements async connectedCallback()

Registration (outside class):
customElements.define("tag-name", ClassName);



DRAGGING & OWNERSHIP RULE ‚Äî CHECKLIST (NEW, MANDATORY)

Dragging must respect component ownership and boundaries.

CORE RULE

‚¨ú A component must not implement rules to drag/reorder itself; only parents may drag/reorder their children.
‚¨ú A Component must NEVER set draggable="true" on its own host element
‚¨ú A Component must NEVER react to drag events (dragstart, dragover, drop) on itself

Law:

A component is a logical unit, not a draggable object.

ALLOWED DRAGGING

‚¨ú Dragging is allowed only for elements inside a component‚Äôs shadow DOM
‚¨ú Draggable elements must be explicit child elements (e.g. cards, rows, list items)
‚¨ú Drag behavior must be attached to internal elements, not the component host


PARENT RESPONSIBILITY RULE

‚¨ú Reordering components is the responsibility of the parent component
‚¨ú Child components must NOT reorder themselves
‚¨ú Child components must NOT coordinate drag-and-drop across siblings

Law:

A component may be moved by its parent, but must never move itself.

DRAG HANDLE RULE (OPTIONAL BUT RECOMMENDED)

If dragging should only start from a specific UI element:

‚¨ú Use an internal drag handle element (icon, grip, header, etc.)
‚¨ú The handle may set a temporary internal flag (e.g. _allowDrag)
‚¨ú The component must still NOT be draggable itself


üß≤ DRAG HANDLE RULE ‚Äî CHECKLIST (MANDATORY)

Dragging is a controlled interaction and must always start from a specific handle element.
No component is allowed to start drag operations from arbitrary internal elements.

Core Principles

‚¨ú Every drag-enabled interaction must have a dedicated Drag Handle element
‚¨ú Only the Drag Handle may initiate a drag
‚¨ú The component itself must never be draggable
‚¨ú Dragging must always be an explicit user action, never implicit

Drag Start Authorization

‚¨ú A drag operation is valid only if it starts from the Drag Handle
‚¨ú If the drag does not originate from the handle, it must be cancelled immediately
‚¨ú No other element inside the component may trigger a drag

Scope of Dragging

‚¨ú Dragging must reorder only container-owned shell elements, never the component tag itself
‚¨ú Child components must not contain rules for dragging or reordering their own custom element
‚¨ú All drag orchestration belongs to the parent container or owner component

Conflict Prevention Rule

‚¨ú Only one drag system may be active for a given gesture
‚¨ú Components must ignore drag events that do not belong to their own drag context
‚¨ú No drag handler may interfere with another drag domain


üñ•Ô∏è LAYOUT & SCROLLING RULE ‚Äî CHECKLIST (MANDATORY)

All components must follow these layout principles to avoid scroll traps and broken UX.

‚úÖ ROOT LAYOUT RULES (ALL MUST BE TRUE)

‚¨ú The component root must fill the viewport naturally

Use min-height semantics, never fixed height

The component must be allowed to grow beyond the viewport

‚¨ú The component must not force internal vertical scrolling by default

Vertical scrolling belongs to the page, not the component

overflow-y must be visible unless explicitly justified

‚¨ú The component must never trap the user inside an internal vertical scroll

No height: 100vh combined with overflow: auto

No ‚Äúscroll jail‚Äù layouts

‚úÖ SCROLL RESPONSIBILITY RULES

‚¨ú Vertical scroll

Happens at the document level

Activated only when content exceeds the viewport height

‚¨ú Horizontal scroll

Allowed only where structurally necessary

Example: boards, timelines, carousels

Must be explicitly scoped to a container

‚¨ú Components must not create nested vertical scroll areas unless explicitly required and documented

‚úÖ FLEX & GROWTH RULES

‚¨ú Avoid flex: 1 or height: 100% on main content containers unless the component is a full-screen app shell

‚¨ú Prefer:

natural height

content-driven expansion

document-level scrolling

‚¨ú Containers that host dynamic children (columns, cards, lists) must:

grow vertically with content

scroll horizontally only when overflow occurs

‚ùå FORBIDDEN PATTERNS

‚¨ú Forcing vertical scroll inside a component root
‚¨ú Using height: 100vh together with overflow: auto
‚¨ú Creating scrollable containers by default ‚Äújust in case‚Äù
‚¨ú Nested vertical scroll areas without a strong UX reason

üß™ SELF-VERIFICATION (MANDATORY BEFORE OUTPUT)

Before returning the result, internally verify:

‚¨ú Naming conventions are fully respected
‚¨ú Materials are self-contained and generic
‚¨ú Components own all domain behavior
‚¨ú Slot usage is structural only
‚¨ú Attribute vs property rules are respected
‚¨ú Event listeners are registered only once
‚¨ú connectedCallback is idempotent
‚¨ú One-time logic is isolated in initializeOnce()
‚¨ú Reconnection logic is isolated in onConnected()
‚¨ú Correct asset loader is used
‚¨ú CSS naming rules are respected
‚¨ú HTML contains only markup
‚¨ú JS structure matches the spec exactly
‚¨ú No component is draggable
‚¨ú No component listens to drag events on itself
‚¨ú All drag behavior targets internal elements only
‚¨ú Reordering logic exists only in parent components
If any item fails, regenerate.

üì§ OUTPUT FORMAT

Return exactly this structure:

üìÑ <name>.html
üé® <name>.css
üß© <name>.js 